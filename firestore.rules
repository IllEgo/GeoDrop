rules_version = '2';
service cloud.firestore {
  function isSignedIn() {
    return request.auth != null;
  }

  function isCurrentUser(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isValidUsername(name) {
    return name is string && name.matches('^[a-z0-9._]{3,20}$');
  }

  function voteValue(data, userId) {
    return (data.voteMap is map && data.voteMap[userId] is int)
      ? data.voteMap[userId]
      : 0;
  }

  function voteCount(data, field) {
    return (data[field] is int) ? data[field] : 0;
  }

  function isValidVoteTransition(before, after, userId) {
    let previousVote = voteValue(before, userId);
    let newVote = voteValue(after, userId);
    let deltaUpvotes = voteCount(after, 'upvoteCount') - voteCount(before, 'upvoteCount');
    let deltaDownvotes = voteCount(after, 'downvoteCount') - voteCount(before, 'downvoteCount');

    return (previousVote in [-1, 0, 1])
      && (newVote in [-1, 0, 1])
      && ((previousVote == newVote && deltaUpvotes == 0 && deltaDownvotes == 0)
        || (previousVote == 0 && newVote == 1 && deltaUpvotes == 1 && deltaDownvotes == 0)
        || (previousVote == 0 && newVote == -1 && deltaUpvotes == 0 && deltaDownvotes == 1)
        || (previousVote == 1 && newVote == 0 && deltaUpvotes == -1 && deltaDownvotes == 0)
        || (previousVote == -1 && newVote == 0 && deltaUpvotes == 0 && deltaDownvotes == -1)
        || (previousVote == -1 && newVote == 1 && deltaUpvotes == 1 && deltaDownvotes == -1)
        || (previousVote == 1 && newVote == -1 && deltaUpvotes == -1 && deltaDownvotes == 1));
  }

  match /databases/{database}/documents {
    match /users/{userId} {
      function hasOnlyAllowedUserFields() {
        return request.resource.data.keys().hasOnly([
          'displayName',
          'username',
          'role',
          'businessName',
          'businessCategories',
          'nsfwEnabled',
          'nsfwEnabledAt'
        ]);
      }

      allow read: if isSignedIn();

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedUserFields()
        && (!request.resource.data.keys().hasAny(['username'])
            || isValidUsername(request.resource.data.username));
    }

    match /usernames/{username} {
      allow read: if isSignedIn();

      allow create, update: if isSignedIn()
        && request.resource.data.keys().hasOnly(['userId'])
        && request.resource.data.userId == request.auth.uid;

      allow delete: if isSignedIn()
        && resource.data.userId == request.auth.uid;
    }

    match /reports/{reportId} {
      function hasOnlyAllowedReportFields() {
        return request.resource.data.keys().hasOnly([
          'dropId',
          'reportedBy',
          'reportedAt',
          'reasonCodes',
          'status',
          'context',
          'dropSnapshot'
        ]);
      }

        function isValidReportReasonCodes() {
          return request.resource.data.reasonCodes is list
            && request.resource.data.reasonCodes.size() > 0
            && request.resource.data.reasonCodes.all(code, code is string && code.size() > 0);
        }

      allow create: if isSignedIn()
        && hasOnlyAllowedReportFields()
        && request.resource.data.reportedBy == request.auth.uid
        && request.resource.data.dropId is string && request.resource.data.dropId.size() > 0
        && request.resource.data.reportedAt is int
        && request.resource.data.status == 'pending'
        && (!request.resource.data.keys().hasAny(['context']) || request.resource.data.context is map)
        && (!request.resource.data.keys().hasAny(['dropSnapshot']) || request.resource.data.dropSnapshot is map)
        && isValidReportReasonCodes();
    }

    match /drops/{dropId} {
      allow get, list: if isSignedIn() || request.auth == null;
      function hasOnlyAllowedDropFields() {
        return request.resource.data.keys().hasOnly([
          'text',
          'description',
          'lat',
          'lng',
          'createdBy',
          'createdAt',
          'isDeleted',
          'deletedAt',
          'groupCode',
          'isAnonymous',
          'dropType',
          'businessId',
          'businessName',
          'contentType',
          'mediaUrl',
          'mediaMimeType',
          'mediaData',
          'mediaStoragePath',
          'isNsfw',
          'nsfw',
          'nsfwLabels',
          'upvoteCount',
          'downvoteCount',
          'voteMap',
          'reportCount',
          'reportedBy',
          'redemptionCode',
          'redemptionLimit',
          'redemptionCount',
          'redeemedBy',
          'decayDays',
          'collectedBy'
        ]);
      }

      function isExplorer() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'EXPLORER';
      }

      function isBusiness() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'BUSINESS';
      }

      function isBusinessDrop(data) {
        return data.dropType is string && data.dropType != 'COMMUNITY';
      }

      allow create: if hasOnlyAllowedDropFields()
        && request.resource.data.createdBy == request.auth.uid
        && (
          (isExplorer() && !isBusinessDrop(request.resource.data))
          || (isBusiness()
            && isBusinessDrop(request.resource.data)
            && request.resource.data.businessId == request.auth.uid)
        );
      function isValidReportTransition(before, after, userId) {
        let beforeReportedBy = (before.reportedBy is map) ? before.reportedBy : {};
        let afterReportedBy = (after.reportedBy is map) ? after.reportedBy : {};
        let beforeKeys = beforeReportedBy.keys();
        let afterKeys = afterReportedBy.keys();
        let hadReport = beforeKeys.hasAny([userId]);
        let hasReport = afterKeys.hasAny([userId]);
        let beforeCount = (before.reportCount is int) ? before.reportCount : 0;
        let afterCount = (after.reportCount is int) ? after.reportCount : 0;
        let diff = beforeReportedBy.diff(afterReportedBy);

        return diff.affectedKeys().hasOnly([userId])
          && (
            (!hadReport && !hasReport && afterCount == beforeCount)
            || (hadReport && hasReport && afterCount == beforeCount)
            || (!hadReport && hasReport && afterCount == beforeCount + 1)
          );
      }

      allow update: if isSignedIn()
        && (
          (
            request.writeFields.hasOnly([
              'voteMap.' + request.auth.uid,
              'upvoteCount',
              'downvoteCount',
              'collectedBy.' + request.auth.uid,
              'reportedBy.' + request.auth.uid,
              'reportCount'
            ])
            && isValidVoteTransition(resource.data, request.resource.data, request.auth.uid)
            && isValidReportTransition(resource.data, request.resource.data, request.auth.uid)
          )
          || (
            resource.data.createdBy == request.auth.uid
            && request.writeFields.hasOnly(['isDeleted', 'deletedAt'])
            && request.resource.data.isDeleted == true
            && request.resource.data.deletedAt is int
          )
        );

      allow delete: if isSignedIn()
        && resource.data.createdBy == request.auth.uid;
    }

    match /users/{userId}/inventory/{dropId} {
      function hasOnlyAllowedInventoryFields() {
        return request.resource.data.keys().hasOnly([
          'id',
          'text',
          'description',
          'contentType',
          'collectedAt',
          'dropType',
          'redemptionCount',
          'isRedeemed',
          'redeemedAt',
          'state',
          'updatedAt',
          'mediaUrl',
          'mediaMimeType',
          'mediaData',
          'lat',
          'lng',
          'groupCode',
          'dropCreatedAt',
          'dropperUsername',
          'createdByUsername',
          'decayDays',
          'businessId',
          'businessName',
          'redemptionLimit',
          'isNsfw',
          'nsfwLabels'
        ]);
      }

      function isValidInventoryState() {
        return !request.resource.data.keys().hasAny(['state'])
          || request.resource.data.state in ['COLLECTED', 'IGNORED'];
      }

      function isValidInventoryTypes() {
        return (!request.resource.data.keys().hasAny(['collectedAt'])
            || request.resource.data.collectedAt is int)
          && (!request.resource.data.keys().hasAny(['redeemedAt'])
            || request.resource.data.redeemedAt is int)
          && (!request.resource.data.keys().hasAny(['updatedAt'])
            || request.resource.data.updatedAt is int)
          && (!request.resource.data.keys().hasAny(['lat'])
            || request.resource.data.lat is number)
          && (!request.resource.data.keys().hasAny(['lng'])
            || request.resource.data.lng is number)
          && (!request.resource.data.keys().hasAny(['nsfwLabels'])
            || request.resource.data.nsfwLabels is list);
      }

      allow read: if isCurrentUser(userId);

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedInventoryFields()
        && isValidInventoryState()
        && isValidInventoryTypes();

      allow delete: if isCurrentUser(userId);
    }
  }
}