rules_version = '2';
service cloud.firestore {
  function isSignedIn() {
    return request.auth != null;
  }

  function isCurrentUser(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isValidUsername(name) {
    return name is string && name.matches('^[a-z0-9._]{3,20}$');
  }

  function voteValue(data, userId) {
    return (data.voteMap is map && data.voteMap[userId] is int)
      ? data.voteMap[userId]
      : 0;
  }

  function voteCount(data, field) {
    return (data[field] is int) ? data[field] : 0;
  }

  function isValidVoteTransition(before, after, userId) {
    let previousVote = voteValue(before, userId);
    let newVote = voteValue(after, userId);
    let beforeUpvotes = voteCount(before, 'upvoteCount');
    let beforeDownvotes = voteCount(before, 'downvoteCount');
    let afterUpvotes = voteCount(after, 'upvoteCount');
    let afterDownvotes = voteCount(after, 'downvoteCount');
    let voteDiff = ((before.voteMap is map) ? before.voteMap : {}).diff(
      (after.voteMap is map) ? after.voteMap : {}
    );
    let normalizedUpvotes = (beforeUpvotes - (previousVote == 1 ? 1 : 0));
    let normalizedDownvotes = (beforeDownvotes - (previousVote == -1 ? 1 : 0));

    return (previousVote in [-1, 0, 1])
      && (newVote in [-1, 0, 1])
      && voteDiff.affectedKeys().hasOnly([userId])
      && afterUpvotes == ((normalizedUpvotes > 0 ? normalizedUpvotes : 0) + (newVote == 1 ? 1 : 0))
      && afterDownvotes == ((normalizedDownvotes > 0 ? normalizedDownvotes : 0) + (newVote == -1 ? 1 : 0));
  }

  match /databases/{database}/documents {
    match /users/{userId} {
      function hasOnlyAllowedUserFields() {
        return request.resource.data.keys().hasOnly([
          'displayName',
          'username',
          'role',
          'businessName',
          'businessCategories',
          'nsfwEnabled',
          'nsfwEnabledAt'
        ]);
      }

      allow read: if isSignedIn();

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedUserFields()
        && (!request.resource.data.keys().hasAny(['username'])
            || isValidUsername(request.resource.data.username));
    }

    match /usernames/{username} {
      allow read: if isSignedIn();

      allow create, update: if isSignedIn()
        && request.resource.data.keys().hasOnly(['userId'])
        && request.resource.data.userId == request.auth.uid;

      allow delete: if isSignedIn()
        && resource.data.userId == request.auth.uid;
    }

    match /reports/{reportId} {
      function hasOnlyAllowedReportFields() {
        return request.resource.data.keys().hasOnly([
          'dropId',
          'reportedBy',
          'reportedAt',
          'reasonCodes',
          'status',
          'context',
          'dropSnapshot'
        ]);
      }

        function isValidReportReasonCodes() {
          let reasonCodes = request.resource.data.reasonCodes;
          let validCodes = (reasonCodes is list)
            ? reasonCodes.where(reasonCode, reasonCode is string && reasonCode.size() > 0)
            : [];

          return reasonCodes is list
            && reasonCodes.size() > 0
            && validCodes.size() == reasonCodes.size();
        }

      allow create: if isSignedIn()
        && hasOnlyAllowedReportFields()
        && request.resource.data.reportedBy == request.auth.uid
        && request.resource.data.dropId is string && request.resource.data.dropId.size() > 0
        && request.resource.data.reportedAt is int
        && request.resource.data.status == 'pending'
        && (!request.resource.data.keys().hasAny(['context']) || request.resource.data.context is map)
        && (!request.resource.data.keys().hasAny(['dropSnapshot']) || request.resource.data.dropSnapshot is map)
        && isValidReportReasonCodes();
    }

    match /drops/{dropId} {
      allow get, list: if isSignedIn() || request.auth == null;
      function hasOnlyAllowedDropFields() {
        return request.resource.data.keys().hasOnly([
          'text',
          'description',
          'lat',
          'lng',
          'createdBy',
          'createdAt',
          'isDeleted',
          'deletedAt',
          'groupCode',
          'isAnonymous',
          'dropType',
          'businessId',
          'businessName',
          'contentType',
          'mediaUrl',
          'mediaMimeType',
          'mediaData',
          'mediaStoragePath',
          'isNsfw',
          'nsfw',
          'nsfwLabels',
          'dropperUsername',
          'upvoteCount',
          'downvoteCount',
          'voteMap',
          'reportCount',
          'reportedBy',
          'redemptionCode',
          'redemptionLimit',
          'redemptionCount',
          'redeemedBy',
          'decayDays',
          'collectedBy'
        ]);
      }

      function isExplorer() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'EXPLORER';
      }

      function isBusiness() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'BUSINESS';
      }

      function isBusinessDrop(data) {
        return data.dropType is string && data.dropType != 'COMMUNITY';
      }

      allow create: if hasOnlyAllowedDropFields()
        && request.resource.data.createdBy == request.auth.uid
        && (
          (isExplorer() && !isBusinessDrop(request.resource.data))
          || (isBusiness()
            && isBusinessDrop(request.resource.data)
            && request.resource.data.businessId == request.auth.uid)
        );
      function isValidReportTransition(before, after, userId) {
        let beforeReportedBy = (before.reportedBy is map) ? before.reportedBy : {};
        let afterReportedBy = (after.reportedBy is map) ? after.reportedBy : {};
        let beforeKeys = beforeReportedBy.keys();
        let afterKeys = afterReportedBy.keys();
        let hadReport = beforeKeys.hasAny([userId]);
        let hasReport = afterKeys.hasAny([userId]);
        let beforeCount = (before.reportCount is int) ? before.reportCount : 0;
        let afterCount = (after.reportCount is int) ? after.reportCount : 0;
        let diff = beforeReportedBy.diff(afterReportedBy);

        return diff.affectedKeys().hasOnly([userId])
          && (
            (!hadReport && !hasReport && afterCount == beforeCount)
            || (hadReport && hasReport && afterCount == beforeCount)
            || (!hadReport && hasReport && afterCount == beforeCount + 1)
          );
      }

      function hasOnlyUserCollectedChange(before, after, userId) {
        let beforeCollectedBy = (before.collectedBy is map) ? before.collectedBy : {};
        let afterCollectedBy = (after.collectedBy is map) ? after.collectedBy : {};

        return beforeCollectedBy.diff(afterCollectedBy).affectedKeys().hasOnly([userId]);
      }

      function isValidVoteReportCollectUpdate(before, after, userId) {
        let diff = before.diff(after);
        let changedKeys = diff.changedKeys();
        let voteKeys = ['voteMap', 'upvoteCount', 'downvoteCount'];
        let voteChanged = changedKeys.hasAny(voteKeys);

        return changedKeys.hasOnly([
            'voteMap',
            'upvoteCount',
            'downvoteCount',
            'collectedBy',
            'reportedBy',
            'reportCount'
          ])
          && (!voteChanged || isValidVoteTransition(before, after, userId))
          && isValidReportTransition(before, after, userId)
          && (!changedKeys.hasAny(['collectedBy'])
            || hasOnlyUserCollectedChange(before, after, userId));
      }

      function isRedeemableDrop(data) {
        return data.dropType is string && data.dropType == 'RESTAURANT_COUPON';
      }

      function isValidRedemptionTransition(before, after, userId) {
        let beforeRedeemedBy = (before.redeemedBy is map) ? before.redeemedBy : {};
        let afterRedeemedBy = (after.redeemedBy is map) ? after.redeemedBy : {};
        let beforeCountValid = !before.keys().hasAny(['redemptionCount']) || before.redemptionCount is int;
        let afterCountValid = after.redemptionCount is int;
        let beforeCount = beforeCountValid ? ((before.redemptionCount is int) ? before.redemptionCount : 0) : 0;
        let afterCount = afterCountValid ? after.redemptionCount : 0;
        let diff = beforeRedeemedBy.diff(afterRedeemedBy);
        let alreadyRedeemed = beforeRedeemedBy.keys().hasAny([userId]);
        let nowRedeemed = afterRedeemedBy.keys().hasAny([userId]);
        let redeemTimestamp = afterRedeemedBy[userId];
        let limit = (before.redemptionLimit is int) ? before.redemptionLimit : null;

        return beforeCountValid
          && afterCountValid
          && !alreadyRedeemed
          && nowRedeemed
          && diff.affectedKeys().hasOnly([userId])
          && redeemTimestamp is int
          && afterCount == beforeCount + 1
          && (limit == null || afterCount <= limit);
      }

      allow update: if isSignedIn()
        && (
          (
            isValidVoteReportCollectUpdate(resource.data, request.resource.data, request.auth.uid)
          )
          || (
            resource.data.createdBy == request.auth.uid
            && request.writeFields.hasOnly(['isDeleted', 'deletedAt'])
            && request.resource.data.isDeleted == true
            && request.resource.data.deletedAt is int
          )
          || (
            isRedeemableDrop(resource.data)
            && request.writeFields.hasOnly([
              'redeemedBy.' + request.auth.uid,
              'redemptionCount'
            ])
            && isValidRedemptionTransition(resource.data, request.resource.data, request.auth.uid)
          )
        );

      allow delete: if isSignedIn()
        && resource.data.createdBy == request.auth.uid;
    }

    match /users/{userId}/inventory/{dropId} {
      function hasOnlyAllowedInventoryFields() {
        return request.resource.data.keys().hasOnly([
          'id',
          'text',
          'description',
          'contentType',
          'collectedAt',
          'dropType',
          'redemptionCount',
          'isRedeemed',
          'redeemedAt',
          'state',
          'updatedAt',
          'mediaUrl',
          'mediaMimeType',
          'mediaData',
          'lat',
          'lng',
          'groupCode',
          'dropCreatedAt',
          'dropperUsername',
          'createdByUsername',
          'decayDays',
          'businessId',
          'businessName',
          'redemptionLimit',
          'isNsfw',
          'nsfwLabels'
        ]);
      }

      function isValidInventoryState() {
        return !request.resource.data.keys().hasAny(['state'])
          || request.resource.data.state in ['COLLECTED', 'IGNORED'];
      }

      function isValidInventoryTypes() {
        return (!request.resource.data.keys().hasAny(['collectedAt'])
            || request.resource.data.collectedAt is int)
          && (!request.resource.data.keys().hasAny(['redeemedAt'])
            || request.resource.data.redeemedAt is int)
          && (!request.resource.data.keys().hasAny(['updatedAt'])
            || request.resource.data.updatedAt is int)
          && (!request.resource.data.keys().hasAny(['lat'])
            || request.resource.data.lat is number)
          && (!request.resource.data.keys().hasAny(['lng'])
            || request.resource.data.lng is number)
          && (!request.resource.data.keys().hasAny(['nsfwLabels'])
            || request.resource.data.nsfwLabels is list);
      }

      allow read: if isCurrentUser(userId);

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedInventoryFields()
        && isValidInventoryState()
        && isValidInventoryTypes();

      allow delete: if isCurrentUser(userId);
    }
  }
}