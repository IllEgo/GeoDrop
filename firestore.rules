rules_version = '2';
service cloud.firestore {
  function isSignedIn() {
    return request.auth != null;
  }

  function isCurrentUser(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isValidUsername(name) {
    return name is string && name.matches('^[a-z0-9._]{3,20}$');
  }

  match /databases/{database}/documents {
    match /users/{userId} {
      function hasOnlyAllowedUserFields() {
        return request.resource.data.keys().hasOnly([
          'displayName',
          'username',
          'role',
          'businessName',
          'businessCategories',
          'nsfwEnabled',
          'nsfwEnabledAt'
        ]);
      }

      allow read: if isSignedIn();

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedUserFields()
        && (!request.resource.data.keys().hasAny(['username'])
            || isValidUsername(request.resource.data.username));
    }

    match /usernames/{username} {
      allow read: if isSignedIn();

      allow create, update: if isSignedIn()
        && request.resource.data.keys().hasOnly(['userId'])
        && request.resource.data.userId == request.auth.uid;

      allow delete: if isSignedIn()
        && resource.data.userId == request.auth.uid;
    }

    match /reports/{reportId} {
      allow create: if isSignedIn();
    }

    match /groups/{groupCode} {
      allow read: if isSignedIn();

      allow create: if isSignedIn()
        && request.resource.data.keys().hasOnly(['ownerId', 'createdAt', 'updatedAt'])
        && request.resource.data.ownerId == request.auth.uid;

      allow update: if isSignedIn()
        && resource.data.keys().hasAny(['ownerId'])
        && resource.data.ownerId == request.auth.uid
        && request.resource.data.keys().hasOnly(['ownerId', 'createdAt', 'updatedAt'])
        && request.resource.data.ownerId == resource.data.ownerId;

      allow delete: if false;
    }

    match /drops/{dropId} {
      function isDropOwner(data, userId) {
        return data.createdBy is string && data.createdBy == userId;
      }

      function isActiveDrop(data) {
        return !(data.keys().hasAny(['isDeleted']) && data.isDeleted == true);
      }

      function hasTruthyValue(value) {
        return (value is bool && value == true)
          || (value is int && value != 0)
          || (value is float && value != 0)
          || (value is timestamp)
          || (
            value is string
            && value.size() > 0
            && !(value.lower() in ['false', '0', 'off', 'no'])
          )
          || (value is map && value.size() > 0)
          || (value is list && value.size() > 0);
      }

      function hasCollectedDrop(data, userId) {
        return (data.collectedBy is map)
          && data.collectedBy.keys().hasAny([userId])
          && data.collectedBy[userId] != null
          && hasTruthyValue(data.collectedBy[userId]);
      }

      function isNsfwDrop(data) {
        return (data.keys().hasAny(['isNsfw']) && data.isNsfw == true)
          || (data.keys().hasAny(['nsfw']) && data.nsfw == true);
      }

      function hasEnabledNsfw(userId) {
        let userRef = /databases/$(database)/documents/users/$(userId);
        let userDoc = exists(userRef) ? get(userRef) : null;
        return isSignedIn()
          && userDoc != null
          && userDoc.data.keys().hasAny(['nsfwEnabled'])
          && userDoc.data.nsfwEnabled == true;
      }

      function canBrowseDrop(data, userId) {
        return (!isNsfwDrop(data)
            || isDropOwner(data, userId)
            || hasEnabledNsfw(userId))
          && (isDropOwner(data, userId)
            || isActiveDrop(data)
            || hasCollectedDrop(data, userId));
      }

      allow get: if (isSignedIn()
          && canBrowseDrop(resource.data, request.auth.uid))
        || (!isSignedIn()
          && isActiveDrop(resource.data)
          && !isNsfwDrop(resource.data));

      // Query level checks rely on the per-document get rule above. Avoid accessing
      // `resource` in a list rule because it is undefined for collection reads.
      allow list: if true;
      function hasOnlyAllowedDropFields() {
        return request.resource.data.keys().hasOnly([
          'text',
          'description',
          'lat',
          'lng',
          'createdBy',
          'createdAt',
          'isDeleted',
          'deletedAt',
          'groupCode',
          'isAnonymous',
          'dropType',
          'businessId',
          'businessName',
          'contentType',
          'mediaUrl',
          'mediaMimeType',
          'mediaData',
          'mediaStoragePath',
          'isNsfw',
          'nsfw',
          'nsfwLabels',
          'dropperUsername',
          'likeCount',
          'likedBy',
          'reportCount',
          'reportedBy',
          'redemptionCode',
          'redemptionLimit',
          'redemptionCount',
          'redeemedBy',
          'decayDays',
          'collectedBy'
        ]);
      }

      function isExplorer() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'EXPLORER';
      }

      function isBusiness() {
        return isSignedIn()
          && exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'BUSINESS';
      }

      function isBusinessDrop(data) {
        return data.dropType is string && data.dropType != 'COMMUNITY';
      }

      allow create: if hasOnlyAllowedDropFields()
        && request.resource.data.createdBy == request.auth.uid
        && (
          (isExplorer() && !isBusinessDrop(request.resource.data))
          || (isBusiness()
            && (
              !isBusinessDrop(request.resource.data)
              || request.resource.data.businessId == request.auth.uid
            ))
        );

      function hasOnlyUserCollectedChange(before, after, userId) {
        let beforeCollectedBy = (before.collectedBy is map) ? before.collectedBy : {};
        let afterCollectedBy = (after.collectedBy is map) ? after.collectedBy : {};
        return beforeCollectedBy.diff(afterCollectedBy).affectedKeys().hasOnly([userId]);
      }

      function isValidLikeReportCollectUpdate(before, after, userId) {
        let allowedWriteFields = [
            'likedBy',
            'likeCount',
            'collectedBy',
            'reportedBy',
            'reportCount'
          ]
          .concat(['likedBy.' + userId])
          .concat(['collectedBy.' + userId])
          .concat(['reportedBy.' + userId]);
        let hasOnlyAllowedFields = before.diff(after).affectedKeys().hasOnly(allowedWriteFields);
        let collectedChanged = before.collectedBy != after.collectedBy;

        return hasOnlyAllowedFields
          && (!collectedChanged || hasOnlyUserCollectedChange(before, after, userId));
      }

      function isRedeemableDrop(data) {
        return data.dropType is string && data.dropType == 'RESTAURANT_COUPON';
      }

      function isValidRedemptionTransition(before, after, userId) {
        let beforeRedeemedBy = (before.redeemedBy is map) ? before.redeemedBy : {};
        let afterRedeemedBy = (after.redeemedBy is map) ? after.redeemedBy : {};
        let beforeCountValid = !before.keys().hasAny(['redemptionCount']) || before.redemptionCount is int;
        let afterCountValid = after.redemptionCount is int;
        let beforeCount = beforeCountValid ? ((before.redemptionCount is int) ? before.redemptionCount : 0) : 0;
        let afterCount = afterCountValid ? after.redemptionCount : 0;
        let diff = beforeRedeemedBy.diff(afterRedeemedBy);
        let alreadyRedeemed = beforeRedeemedBy.keys().hasAny([userId]);
        let nowRedeemed = afterRedeemedBy.keys().hasAny([userId]);
        let redeemTimestamp = afterRedeemedBy[userId];
        let limit = (before.redemptionLimit is int) ? before.redemptionLimit : null;

        return beforeCountValid
          && afterCountValid
          && !alreadyRedeemed
          && nowRedeemed
          && diff.affectedKeys().hasOnly([userId])
          && redeemTimestamp is int
          && afterCount == beforeCount + 1
          && (limit == null || afterCount <= limit);
      }

      function hasUserCollectedBeforeOrAfter(before, after, userId) {
        return hasCollectedDrop(before, userId)
          || hasCollectedDrop(after, userId);
      }

      allow update: if isSignedIn()
        // && (
        //  (
        //    isValidLikeReportCollectUpdate(resource.data, request.resource.data, request.auth.uid)
        //    && (
        //      isDropOwner(resource.data, request.auth.uid)
        //      || hasUserCollectedBeforeOrAfter(resource.data, request.resource.data, request.auth.uid)
        //    )
        //  )
          || (
            resource.data.createdBy == request.auth.uid
            && resource.data.diff(request.resource.data).affectedKeys().hasOnly(['isDeleted', 'deletedAt'])
            && request.resource.data.isDeleted == true
            && request.resource.data.deletedAt is int
          )
          || (
            isRedeemableDrop(resource.data)
            && resource.data.diff(request.resource.data).affectedKeys().hasOnly([
              'redeemedBy.' + request.auth.uid,
              'redemptionCount'
            ])
            && isValidRedemptionTransition(resource.data, request.resource.data, request.auth.uid)
          )
        // );

      allow delete: if isSignedIn()
        && resource.data.createdBy == request.auth.uid;
    }

    match /users/{userId}/groups/{groupCode} {
      allow read: if isCurrentUser(userId);

      allow create, update: if isCurrentUser(userId)
        && request.resource.data.keys().hasOnly(['code', 'role', 'ownerId', 'updatedAt'])
        && (!request.resource.data.keys().hasAny(['code'])
          || request.resource.data.code is string)
        && (!request.resource.data.keys().hasAny(['role'])
          || request.resource.data.role in ['OWNER', 'SUBSCRIBER'])
        && (!request.resource.data.keys().hasAny(['ownerId'])
          || request.resource.data.ownerId is string)
        && (!request.resource.data.keys().hasAny(['updatedAt'])
          || request.resource.data.updatedAt is int)
        && (let groupDoc = get(/databases/$(database)/documents/groups/$(groupCode));
          groupDoc != null
          && (
            !request.resource.data.keys().hasAny(['ownerId'])
            || (
              groupDoc.data.keys().hasAny(['ownerId'])
              && groupDoc.data.ownerId == request.resource.data.ownerId
            )
          ));

      allow delete: if isCurrentUser(userId);
    }

    match /users/{userId}/inventory/{dropId} {
      function hasOnlyAllowedInventoryFields() {
        return request.resource.data.keys().hasOnly([
          'id',
          'text',
          'description',
          'contentType',
          'collectedAt',
          'dropType',
          'redemptionCount',
          'isRedeemed',
          'redeemedAt',
          'likeCount',
          'isLiked',
          'state',
          'updatedAt',
          'mediaUrl',
          'mediaMimeType',
          'mediaData',
          'lat',
          'lng',
          'groupCode',
          'dropCreatedAt',
          'dropperUsername',
          'createdByUsername',
          'decayDays',
          'businessId',
          'businessName',
          'redemptionLimit',
          'isNsfw',
          'nsfwLabels'
        ]);
      }

      function isValidInventoryState() {
        return !request.resource.data.keys().hasAny(['state'])
          || request.resource.data.state in ['COLLECTED', 'IGNORED'];
      }

      function isValidInventoryTypes() {
        return (!request.resource.data.keys().hasAny(['collectedAt'])
            || request.resource.data.collectedAt is int)
          && (!request.resource.data.keys().hasAny(['redeemedAt'])
            || request.resource.data.redeemedAt is int)
          && (!request.resource.data.keys().hasAny(['likeCount'])
            || request.resource.data.likeCount is int)
          && (!request.resource.data.keys().hasAny(['isLiked'])
            || request.resource.data.isLiked is bool)
          && (!request.resource.data.keys().hasAny(['updatedAt'])
            || request.resource.data.updatedAt is int)
          && (!request.resource.data.keys().hasAny(['lat'])
            || request.resource.data.lat is number)
          && (!request.resource.data.keys().hasAny(['lng'])
            || request.resource.data.lng is number)
          && (!request.resource.data.keys().hasAny(['nsfwLabels'])
            || request.resource.data.nsfwLabels is list);
      }

      allow read: if isCurrentUser(userId);

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedInventoryFields()
        && isValidInventoryState()
        && isValidInventoryTypes();

      allow delete: if isCurrentUser(userId);
    }
  }

    match /users/{userId}/notificationTokens/{tokenId} {
      function hasOnlyAllowedTokenFields() {
        return request.resource.data.keys().hasOnly([
          'token',
          'platform',
          'updatedAt'
        ]);
      }

      allow read: if isCurrentUser(userId);

      allow create, update: if isCurrentUser(userId)
        && hasOnlyAllowedTokenFields()
        && request.resource.data.token is string
        && (!request.resource.data.keys().hasAny(['platform'])
          || request.resource.data.platform is string)
        && (!request.resource.data.keys().hasAny(['updatedAt'])
          || request.resource.data.updatedAt is int);

      allow delete: if isCurrentUser(userId);
    }
}